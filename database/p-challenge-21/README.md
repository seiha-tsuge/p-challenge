# 課題 21

## 課題 1

### 問題 1

デッドロックとは、複数のトランザクションがお互いが所有するロックの解放を待ち合わせてしまい、どちらも処理が進まなくなる状況のことです。例えば、トランザクションAがリソース1をロックしてリソース2の解放を待っている間に、トランザクションBがリソース2をロックしリソース1の解放を待っている状態です。この状況では、どちらのトランザクションも他方のリソースが解放されることなく、進行が停止し、リソースの解放もできなくなります。そのため、両トランザクションは無限に待ち続けることになります。

https://zenn.dev/gibjapan/articles/1d8dfb7520dabc

### 問題 2

- 実際に世の中でデッドロックが発生した事例を1つ調べて、その原因と解決方法を紹介してください

SELECT ... FOR UPDATE クエリの結果が0行: SELECT COUNT(*) FROM users WHERE room_id = ? FOR UPDATE クエリが0行にマッチすると、排他ロックは掛からない。このクエリは部屋にいるユーザー数を取得するためのもの。

ネクストキーロック（ギャップロック）: これはファントム問題を防ぐためのロック機構。クエリで指定された範囲とその間の「ギャップ」にロックがかかる。この例では、room_id にインデックスがあるため、room_id の「-無限大 〜 +無限大」範囲にギャップロックがかかる。

InnoDB のギャップロックの共有性: InnoDBでは、ギャップロックは他のトランザクションがギャップに挿入するのを防ぐ「共有ロック」として扱われる。これにより、複数のトランザクションが同じ範囲のギャップロックを重複して取得することが可能。

デッドロックの発生: user1とuser2のトランザクションが共にユーザーのroom_idを更新しようとすると、各トランザクションが他方のロックの開放を待つ状況になる。しかし、ギャップロックが共有ロックとして重複できるため、どちらのトランザクションも待機状態に入らず、結果的にデッドロックが発生する

[「トランザクション張っておけば大丈夫」と思ってませんか？ バグの温床になる、よくある実装パターン](https://zenn.dev/tockn/articles/4268398c8ec9a9#%E3%83%87%E3%83%83%E3%83%89%E3%83%AD%E3%83%83%E3%82%AF%E3%81%AE%E5%8E%9F%E5%9B%A0%E3%82%92%E6%8E%A2%E3%82%8B)  
[MySQLで発生し得る思わぬデッドロックと対応方法](https://zenn.dev/shuntagami/articles/ea44a20911b817)

### 問題 3

| 分離レベル       | ダーティライト | ダーティリード | ファジーリード | ファントム |
|----------------|------------|------------|------------|--------|
| READ UNCOMMITTED | ありえない     | 可能         | 可能         | 可能     |
| READ COMMITTED   | ありえない     | ありえない      | 可能         | 可能     |
| REPEATABLE READ  | ありえない     | ありえない      | ありえない      | 可能     |
| SERIALIZABLE     | ありえない     | ありえない      | ありえない      | ありえない  |

[TiDBトランザクション分離レベル](https://docs.pingcap.com/ja/tidb/stable/transaction-isolation-levels)  
[トランザクション分離レベルについてのまとめ](https://qiita.com/song_ss/items/38e514b05e9dabae3bdb)

#### READ UNCOMMITTED

特徴: コミットされていない変更を他のトランザクションから参照できる設定です。  
問題点: ダーティリードが生じる可能性があります。

#### READ COMMITTED 

特徴: コミットされた変更を他のトランザクションから参照できる設定です。  
問題点: ファジーリードが生じる可能性があります。

#### REPEATABLE READ

特徴: コミットされた追加・削除を他のトランザクションから参照できる設定です。  
問題点: ファントムリードが生じる可能性があります。

#### SERIALIZABLE

特徴: 強制的にトランザクションを順序付けて処理する一番高いトランザクション分離レベルです。  
問題点: 性能が大きく低下することがあります。

#### ダーティライト

一つのトランザクションがまだ完了（コミットまたはロールバック）していないデータを、別のトランザクションが更新してしまう状況を指します。

#### ダーティリード

ダーティリードは、あるトランザクションがまだ完了していない（コミットされていない）データを、別のトランザクションが読み取る現象を指します。この状況では、データの整合性が損なわれるリスクがあります。例えば、トランザクションAが最終的に失敗すると、トランザクションBによって読み取られたデータは不正確になる可能性があります。

#### ファジーリード

ファジーリードは、トランザクションの実行中に他のトランザクションによってコミットされたデータを読み取る現象です。

#### ダーティリードとファジーリードの違い

ダーティリードは「まだ確定していないデータ」を読むことであり、ファジーリードは「確定した後のデータ」を読むことです。
ダーティリードはデータの不整合を引き起こす可能性が高いのに対して、ファジーリードは最新の確定データを反映しますが、トランザクションの実行中にデータが変わる可能性があります。

#### ファントムリード

ファントムリードは、データベースのトランザクション処理における一種の現象です。これは、一つのトランザクションが、あるクエリを2回実行する間に、別のトランザクションがデータベースに新しいレコードを挿入または削除すると発生します。結果として、最初のトランザクションの2回のクエリ結果が異なる可能性があります。

たとえば、あるトランザクションが特定の条件に合致するレコードの数を数えるクエリを実行します。その間に、別のトランザクションが同じ条件に合致する新しいレコードを挿入します。最初のトランザクションが同じクエリを再度実行すると、レコードの数が異なる結果が得られます。これは「ファントム（幽霊）」のように、最初のクエリ実行時には存在しなかったデータが「現れた」ために起こる現象です。

### 問題 4

| 特性 | 行レベルのロック | テーブルレベルのロック |
|------|---------------------------------|--------------------------------------|
| **粒度** | 個々の行に対して適用 | テーブル全体に適用 |
| **競合の少なさ** | 同時に多くのユーザーが異なる行を操作できるため、競合が少ない | テーブル全体がロックされるため、他のユーザーがそのテーブルのどの行も操作できず、競合が多くなる |
| **パフォーマンス** | 多くのトランザクションが同時に行われる場合に良いパフォーマンスを提供 | 小規模な操作や、データベースへのアクセスが少ない場合に効果的 |
| **オーバーヘッド** | 各行にロックを管理するためのオーバーヘッドが大きい | 行ごとではなくテーブル全体に対するロック管理のため、オーバーヘッドは比較的少ない |
| **適用例** | 多くのユーザーがデータベースにアクセスし、異なるデータを頻繁に更新する場合に適している | 単純なアプリケーションや、競合の少ない環境での使用に適している |

[ロック・レベル](https://docs.oracle.com/cd/F52398_01/introduction/locking-levels.html#GUID-C756A360-6F8B-4D3A-A937-ED0C8C0F0644)

### 問題 5

| 要素          | 悲観ロック                          | 楽観ロック                         |
|---------------|-------------------------------------------------------|-------------------------------------------------------|
| **アプローチ**    | データにアクセスする際にロックをかけ、他のトランザクションのアクセスを防ぐ。 | データを読み込み、更新時に変更されていないことを確認。競合があれば再試行または中止。 |
| **使用時**      | データ競合が頻繁に起こる状況、または競合コストが高い場合。                   | データ競合がまれで、トランザクションが短時間の場合。                    |
| **欠点**       | 他のトランザクションの待ち時間が長くなり、システムのスループットが低下する可能性。  | 競合時にトランザクションの再試行や中止が必要になる場合があり、効率が低下する可能性。   |

#### 悲観ロック

悲観ロックは、他者が頻繁にデータを変更する可能性が高いという前提の下で使用されます。

この手法では、トランザクションが開始されると同時に、対象となるデータレコードに対してロックがかけられます。このロックはトランザクションがコミットまたはロールバックされるまで維持され、その間、他のトランザクションによるデータの更新は阻止されます。これにより、データの整合性が保たれます。

一般的に、悲観ロックはRDBMSで「SELECT 〜 FOR UPDATE」文を使用して実装されます。重要なのは、データ更新後に確実にロックを解放することです。ロック解放が適切に行われない場合、データベースは他のトランザクションによる操作を許可しなくなります。
しかし、処理中の予期せぬ中断（例えば、Webアプリケーションでブラウザが閉じられたり、PCがシャットダウンされたりするケース）によってロックが解放されないことがあります。

これらの問題に対処するためには、以下のような戦略が有効です：

- 管理者がロックを手動で解放できる機能の実装。
- ロックしているユーザがロックを再取得できるメカニズムの提供。
- ユーザのセッションタイムアウト時に自動的にそのユーザが保持するロックを解放するシステム。
- 長時間維持されたロックを自動的に解放する機能の導入。

#### 楽観ロック

楽観ロックは、他者による同時更新が稀であるという前提に基づく排他制御の一種です。

この方法では、データ自体にロックをかけずに、更新時にデータが取得時と同じ状態であるかを確認することでデータの整合性を保ちます。
具体的には、アプリケーションがデータを読み取る際にロックはかけず、更新を試みる際には、読み取り時と同じ状態のデータにのみ更新を適用します。

整合性の確認には「バージョン番号」や「タイムスタンプ」などのデータ属性が使われます。
読み取り時と更新時のバージョン番号が異なる場合、他のトランザクションによる更新があったと判断されます。
競合が検出された場合は、アプリケーションがトランザクションの再試行、ユーザーへの通知、または他のエラー処理手順を実行して解決します。

楽観ロックのメリットは、データベースのロックによるオーバーヘッドが少なく、特にデータの読み取りが多く更新が少ないアプリケーションで性能を向上させる点です。
ただし、更新競合が頻繁に起こる環境では、競合解決のための処理がオーバーヘッドとなることもあります。

[排他制御（楽観ロック・悲観ロック）の基礎　](https://qiita.com/NagaokaKenichi/items/73040df85b7bd4e9ecfc)

### 問題 6

|                | 他のTXから読み取れる | 他のTXから変更できる | 自分のTXから変更できる | 他のTXから排他ロックを取得できる | 他のTXから共有ロックを取得できる |
|----------------|-------------------|-------------------|-------------------|---------------------------|---------------------------|
| 排他ロック         | o                 | x                 | o                 | x                         | x                         |
| 共有ロック         | o                 | x                 | △                 | x                         | o                         |

#### 共有ロック

共有ロックはデータの読み取り（参照）の際に使用され、このロックがかけられている間、他のトランザクションもそのデータを読み取ることができます。しかし、共有ロックがかけられているデータは、そのロックが解除されるまで更新（書き込み）できません。

#### 排他ロック

排他ロックは、データベース内のデータを更新する際に用いられるロックの一種です。このロックがかけられている間、そのデータに対しては他のトランザクションからの書き込みや更新ができなくなります。つまり、ロックがかかっているデータに対して、そのトランザクションだけが書き込みや更新を行うことができる状態になります。ただし、他のトランザクションがそのデータを読み取る（参照する）ことは可能です。

[データベースのロックの基礎からデッドロックまで](https://zenn.dev/gibjapan/articles/1d8dfb7520dabc)  
[共有ロック、占有ロック、そしてデッドロックの仕組みを学ぼう！](https://itmanabi.com/exclusive-lock/)

#### 問題 7

SELECT ... FOR UPDATE は、排他ロック

[MySQLのロック機構（SELECT FOR UPDATE）](https://zenn.dev/shuhei_takada/books/3ff66325f45adc/viewer/55e4f6)

### 問題 7

ファジーリードとは、トランザクションが実行されている間に、他のトランザクションによってコミットされたデータを読み取る現象を指します。これは他のトランザクションによって更新されたデータの読み取りに関連しています。一方、ファントムリードは、一つのトランザクションが同じクエリを2回実行する間に、別のトランザクションがデータベースに新しいレコードを挿入または削除することにより生じます。これは他のトランザクションによる新しいレコードの挿入や削除がクエリ結果を変えることに関連しています。

## 課題 2

- 以下の状況を再現するようなクエリを発行してください
    - Dirty Read
    - Non-repeatable read
    - Phantom read
- クエリを作成したら、トリオの方と見せ合って比較してみましょう

ヒント：上記の状況を再現するためには複数のクライアントから同時にMySQLに接続する必要があります

- 映画のチケットを販売するシステムを開発しているとします。映画の予約は（前時代的ですが）映画館に設置されている10台程度の端末でしか行われないため、よほど運が悪くない限り多重予約が発生することはありません
    - このような状況では楽観ロックを利用するでしょうか？それとも悲観ロックを利用するでしょうか？
    - 上記の仕組みを楽観ロックで実装するとしたら、どのようなアプリケーションの流れになりますか？以下のような疑似コードでも、シーケンス図でも構わないので、楽観ロックを用いた排他制御の流れを説明してみてください
        - （ちなみに以下のコードは楽観ロックに対応していないため、あっさり多重予約が発生してしまいます）
        - food for thought: 外部APIを用いた決済と自分たちが管理しているDBへの永続化を行う場合、どちらを先に実施するのが良いのでしょうか？
          - ヒント：ロールバックのしやすさ、どのようなエラーが起きると事業にとって致命的かを考えてみると良いかもしれません。上記の疑似コードの順番だとどのような問題がありそうでしょうか...?