# 課題 15

## 課題 1

### 問題 1

ある本から特定の単語を見つけ出したいとき、最初のページから一枚一枚ページをめくって探すのは時間がかかってしまう。
本の索引はこの手間を省略し、目的の単語が何ページ目にあるのかを示してくれるので、直接該当ページに飛ぶことができる。  
インデックスをプログラミング言語的な表現をすると(x: a)の連想配列になる。xはキーで、aはそれに結びつく実データあるいはポインタを意味する。
実際のデーターベースでは、aはデータへのポインタであることが多い。  
索引もキーとなる単語とページ番号の連想配列となっている。  

[参考: 達人に学ぶDB設計 徹底指南書 ～初級者で終わりたくないあなたへ](https://www.shoeisha.co.jp/book/detail/9784798124704)

### 問題 2

インデックスを使うかどうかは、DBMSが自動的に判断する。
ゆえに、作成したインデックスが、必ずしも使われるわけではない。
また、手当たり次第に作成しても効果が出るわけではなく、正しい指針を理解した上で使って初めて効果が得られる。
そのため、スロークエリーログを使用して、インデックスの成果を確かめる必要がある。

[参考: 達人に学ぶDB設計 徹底指南書 ～初級者で終わりたくないあなたへ](https://www.shoeisha.co.jp/book/detail/9784798124704)

### 問題 3

インデックスを作成する列の適否を判断するために、最も重要な情報が「カーディナリティ」である。
カーディナリティは、あるカラムの値が、どのぐらいの種類の多さを持つか、ということを表す概念になる。  
例えば、「性別」を表すカラムが持つ値として、次のようなものが考えられる。

1. 男性
1. 女性
1. 不詳

この場合、カーディナリティは「3」になる。

インデックスを作るときは、カーディナリティの高い列を選ぶことが基本となる。
例えば、「顧客の口座番号」や「誕生日」のカーディナリティは、非常にたくさんの種類があると想定される。
目安としては、特定のキー値を指定した時に、全体のレコード数の5%程度に絞り込めるだけのカーディナリティがあること。
365日のうち1日を指定するSELECT文を考えると、0.3%に絞り込めるため、「誕生日」にインデックスを作る意味はある、と判断できる。

[参考: 達人に学ぶDB設計 徹底指南書 ～初級者で終わりたくないあなたへ](https://www.shoeisha.co.jp/book/detail/9784798124704)

### 問題 4

インデックスのはたらきによって、テーブルアクセスしなくても良かった場合のことを、 カバリングインデックスと言う。  
[インデックスのみのスキャン: テーブルアクセスを 避ける](https://use-the-index-luke.com/ja/sql/clustering/index-only-scan-covering-index)

クエリを処理するのに必要なデータを全て含んでいるようなインデックスをカバリングインデックスと呼ぶ。  
[MySQL カバリングインデックス](https://qiita.com/riita10069/items/29953f51126ed4e0cf82)

インデックスに結果セットに必要なすべてのカラムが含まれている (カバリングインデックスと呼ばれます) 場合、クエリーはテーブルデータをまったく読み取らなくても済む可能性がある。  
[8.5.5 InnoDB クエリーの最適化](https://dev.mysql.com/doc/refman/5.6/ja/optimizing-innodb-queries.html)

## 課題 2

``` SQL
SELECT * FROM dept_emp WHERE from_date = '1986-06-26';
```

<img width="754" alt="スクリーンショット 2022-10-04 22 47 04" src="https://user-images.githubusercontent.com/49358142/193836861-6f8b63fe-075b-4a30-ba46-a74ba06de6cc.png">


``` SQL
SELECT * FROM INFORMATION_SCHEMA.ENGINES WHERE ENGINE='PERFORMANCE_SCHEMA'
```

- ここからの課題では、実際にMySQLインスタンスを立ち上げて、色々といじっていきます
- WHERE句を1つだけ含むSELECTクエリを3つ考えてください
  - WHERE句を複数含む場合のインデックスについては次の課題で触れるため、**この課題ではWHERE句は1つだけでお願いします**
  - クエリを実行して、取得に要した時間を測定してください
    - ヒント：SHOW PROFILESという簡単な測定方法がありますが...
      - 今回のように簡単な実験であれば問題ありませんが、SHOW PROFILESはMySQLからdeprecate予定なので、使用する場合はご注意ください
    - ヒント：performance_schemaを使うのが良さそうです！
  - 上記のSELECTクエリを高速化するインデックスを作成してください
  - インデックスを使って検索した場合どれだけ検索速度に差が出るか、測定してください
  - EXPLAINを使って、ちゃんとインデックスが使われていることを証明してください

**！注意！**

- データ量やクエリによっては、MySQLが実行計画を作成する際に、**インデックスを使わない方がデータを早く取得できる**と判断して、インデックスが使われないことがあります
