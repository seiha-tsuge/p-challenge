# 課題34

## 課題1

### エンティティ

エンティティとは、一意なものを表現するオブジェクト。一意であるため、長期にわたって変化できるオブジェクトとなる。例えば「社員」というエンティティの場合、社員番号で社員を一意に識別することで、同じ人物であることを把握し、住所や所属といった属性を適切に変更できる。

### 値オブジェクト（バリューオブジェクト）

値オブジェクトとは、一意に識別する必要がないオブジェクト。従来はシンプルな文字列型や数値型で実装してしまうような情報を「値オブジェクト」として実装することで、業務をコードとして表現できるようになる。DDDにおける「値オブジェクト」は何かを計測したり、定量化したりして説明する際に使用するオブジェクト。数字/文字列/日付をはじめ、性/名/金額/色といった「ユビキタス言語」を表現するために活用する。例えば、電話番号を表すために数値型(INT型)を使うのではなくPhoneNumber型を作ることで、ドメインの業務をプログラムでわかりやすく示すことができる。

### 集約

集約とは、トランザクション整合性を保ちながら更新を行うオブジェクトのまとまりを示す。DDDにおける集約とは、オブジェクトのまとまりを表し、整合性を保ちながらデータを更新する単位となる。通常はオブジェクトの集まりの「境界線」の意味で使われ、オブジェクト群の生成/読み込み/変更/保存といったライフサイクル管理が行われる。

### ユビキタス言語

ユビキタス言語とは、ドメインエキスパートや開発者を含めたチーム全体で作り上げる共有言語のこと。同じ用語を使って話すという表面的なものではなく、日本語という自然言語をもとにした「チーム全体で作り上げる特別な共有言語」であり、ドメイン固有言語の一種ともいえる。例えば、「商品」や「在庫」という言葉ひとつを取っても、それは「境界づけられたコンテキスト」ごとに違うニュアンスと振る舞いを持つ。ユビキタス言語は、そのままコードとして実装される。

### 境界づけられたコンテキスト

ドメインの課題を解決する部分を「境界づけられたコンテキスト」と呼ぶ。１つの「コアドメイン（もしくはサブドメイン）」に、１つの「境界づけられたコンテキスト」が対応している状態が最適だとされている。DDDでは、共通言語として「ユビキタス言語」を作り上げ、そのモデルに沿って実装する。そこで、ユビキタス言語の意味が変わる境界で「境界づけられたコンテキスト」を分割して管理する。DDDの「コンテキスト」は「企業や組織の文化」に近い意味を持つ。つまり「境界付られたコンテキスト」はユビキタス言語が複数の意味を持たないようにするための明示的な境界といえる。

### ドメイン

ドメインとは、対象する事業が取り扱う世界を表す。この世界には独自のルールと文化が存在する。良い開発を行うには、この世界をチームメンバーが深く理解する必要がある。しかし、すべての仕組みを理解するにはあまりにも大きく複雑すぎるため、通常は「コアドメイン」「サブドメイン」という適切な大きさに分割する。「コアドメイン」とは事業的に最も重要で戦略的に不可欠な部分。「コアドメイン」ではない補助的な部分（システム的には必要でありつつもコアドメインではない部分）を「サブドメイン」と呼ぶ。

### ドメインサービス

DDDには、「エンティティ」「値オブジェクト」「集約」といった「ドメインオブジェクト」だけではなく、それらの外に記述した方がよいロジックも存在する。そのような時に使用できるのが、状態を持たないステートレスな「サービス」。
ドメインサービスは、エンティティや値オブジェクトの責務ではないドメインモデルのロジック（複数のドメインオブジェクトを使って計算する処理やFacade）。ドメインサービスの特徴は、ドメイン層の中に含まれ、ビジネスロジックを持つことができる点にある。
一般的に「サービス」という言葉は、ビジネスロジックを使い易い粒度にまとめたコンポーネントという意味合いで使われたり、RESTを用いた分散システムでのメッセージの送受信を担うWebサービスという意味合いで使われたりする。しかし、DDDの「ドメインサービス」は従来の「サービス」が示すものとは異なる。「ドメインサービス」は粒度が粗いコンポーネントやWebサービスではなく、トランザクションの責務を担うわけでもない。ドメインサービスの役割は、ドメインモデルが扱う「粒度の細かい振る舞い」を担うもの。その処理を担う場所が「エンティティ」「値オブジェクト」「集約」でもない場合に、ドメインサービスとして実装する。そのため、ドメインサービスはユビキタス言語として表現される。

### リポジトリ

一般的に「リポジトリ」とはデータの「保管庫」を表す。DDDにおけるリポジトリは、「エンティティ」や「値オブジェクト」から構成される「集約」の格納と取得を担当する。リポジトリは、クライアントへ集約を提供し、背後のデータベースとのやり取りを隠蔽する。通常、集約とリポジトリの関係は１対１になる。例えば「注文」の集約を利用したい場合は「注文リポジトリ」を使用する。クライアント側はリポジトリのおかげで、物理的な構成（RDBなのか、NoSQLなのかなど）を意識せずに、簡単に集約を操作できる。

### アプリケーション（ユースケース層と呼ばれることも）

アプリケーションの広義の意味はシステム全体と同じ。利用用途（ユースケース）に応じた調整役を実施。アプリケーションの責務は、タスクの調整であり、ユースケースのイベントフローごとにメソッドを提供する。アプリケーションはあくまで調整役であるため、薄い処理を行うだけのレイヤーとなる。アプリケーションが調整する対象は、単一の境界づけられたコンテキストの場合もあれば、複数のコンテキストにまたがる場合もある。

### CQS/CQRS

コマンドクエリ責務分離(CQRS:Command Query Responsibility Segregation)とは、その名前のとおりコマンドとクエリを分離することで、更新と取得それぞれに特化したモデルと処理を実装する。CQRSパターンのもとになっている原則は、コマンドとクエリを分解するアーキテクチャパターンであるCQS(Command Query Separation)。これはBertrand Meyerが書籍『オブジェクト指向入門』にて提唱した。実装レベルに要約すルト次の２つに分けられる。

1. コマンド(Write): オブジェクトの状態を変更するメソッドは値を戻してはいけない。戻り値の型はVoidである
1. クエリ(Read): メソッドが型や値を戻す場合、オブジェクトの状態を変更してはイケニア

従来のプログラミングでは、更新と取得を同じメソッドで記述していたかもしれないが、CQRSでは「更新メソッド」と「結果取得メソッド」として明確に２つに分離する。

### DTO

システム上で何かを描画するときは、複数の集約にアクセスして情報を取り出し、UI層に受け渡す。その際の方法として、複数の集約の情報を「データ変換オブジェクト(DTO)」に詰め替える方法が挙げられる。この場合、まずアプリケーションは、リポジトリ経由で複数の集約を首都kする。次に、DTOに値を設定する。
