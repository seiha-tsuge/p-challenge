# 課題 9

## 課題 3

### 問題 1

#### そもそも、なぜ元の関数はカバレッジ 100%のテストを書けなかったのでしょうか？

`asyncSumOfArraySometimesZero`は、`DatabaseMock`に、
`getFirstNameThrowIfLong`は、`NameApiService`に、不規則に例外を発生させるクラスに依存していた。
そのため、テストコードの結果が不規則な状態であり、常に安定したガバレッジを出すことができなかった。

#### 依存性の注入とは何でしょうか？

1. 依存とは？

「依存」とは、あるクラスが別のクラスをフィールドで持つことや、メソッドを利用することを指す。  
例えば、以下のようなコードになる。

```Java
public class SomeObjectA {
  private SomeObjectB objB;

  public SomeObjectA(SomeObjectB objB) {
    this.objB = objB;
  }

  public void methodA() {
    objB.methodB();
  }
}
```

もし、SomeObjectB のメソッドに引数を追加すると、SomeObjectA はコードを修正しなければならない。つまり、SomeObjectA は SomeObjectB に依存している。

2. 注入とは何か？

注入とは、変数にインスタンスを代入すること。  
先程のサンプルコードで言うと、コンストラクタ内でフィールドにインスタンスを代入している。

```Java
  public SomeObjectA(SomeObjectB objB) {
    this.objB = objB;
  }
```

インスタンスを代入しないと、objB は null になってしまう。この状態では、objB のメソッドを呼び出してもエラーが発生してしまう。

3. 依存性の注入とは何か？

依存性の注入とは、インターフェースや抽象クラスを継承したクラスのインスタンスを代入すること。

例えば、Java には List というインターフェースがある。そのインターフェースを実装したクラスでなければ、インスタンスを代入できない。List インターフェースを実装した ArrayList クラスを注入する場合、以下のようなコードを書く

```Java
List<Object> list = new ArrayList<>()
```

インターフェースや抽象クラスには、それを継承したクラスが複数存在することがある。List インターフェースを実装したクラスは、ArrayList や LinkedList などがある。  
複数の実装クラスが存在する場合は、以下の 2 つの処理を行う必要がある。

- どの実装クラスを使用するのか（依存）
- そのクラスのインスタンスを変数に入れる（注入）

つまり、List に ArrayList を注入するのか、LinkedList を注入するのかを決める。  
「依存」と「注入」を合わせて、「依存性の注入」となる。

[参考: 後悔しないための Spring Boot 入門書：Spring 解体新書（第 2 版）: Spring Boot が丸分かり Spring 解体新書](https://www.amazon.co.jp/%E5%BE%8C%E6%82%94%E3%81%97%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%E3%81%AESpring-Boot-%E5%85%A5%E9%96%80%E6%9B%B8%EF%BC%9ASpring-%E8%A7%A3%E4%BD%93%E6%96%B0%E6%9B%B8%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89-Spring%E8%A7%A3%E4%BD%93%E6%96%B0%E6%9B%B8-ebook/dp/B08XPBPH9C/ref=sr_1_2?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&keywords=%E5%BE%8C%E6%82%94spring&qid=1638163916&sr=8-2)

#### どのような問題を解決するために使われるのでしょうか？

依存性があるコードは保守やテストが難しくなるので、それを解決するために使われる。
依存性の注入を行うことで、以下のようなメリットがある。

- 処理内容の追加・変更ができる
- テストがしやすくなる

【処理内容の追加・変更ができる】  
インターフェースを使うことで、クラスを変更できる。つまり、処理の中身を変更できる。例えば、List を実装した ArrayList と LinkedList では中身の処理が異なる。そのため、以下ように長所と短所がある。

- ArrayList
  - 長所: 要素にアクセスするのが速い
  - 短所: 要素の追加が遅い
- LinkedList
  - 長所: 要素の追加が速い
  - 短所: 要素にアクセスするのが遅い

処理を変更できる状態にしておけば、それだけ変更に強くなり拡張性が高まる。インターフェースにしておけば実装クラスを切り替えるのは簡単になる。しかし、実装クラスをそのまま使ってしまうと、そのクラスだけに依存してしまうことになる。

```Java
// 実装クラスを変更できる（疎結合）
List<Object> listA = new ArrayList<>()
// ArrayList以外に変更できない（密結合）
ArrayList<Object> listB = new ArrayList<>()
```

実装クラスに依存してしまうことを密結合という。そして、インターフェースに依存することを疎結合という。クラス図で見ると以下のようになる。

<img width="529" alt="スクリーンショット 2021-11-29 15 47 41" src="https://user-images.githubusercontent.com/49358142/143821070-aaee4b7c-058b-4e9f-959d-b32820919b44.png">

疎結合では List に依存しているのが分かる。そのため、ArrayList にも LinkedList にも変更できる。あるいは、List を実装した新しいクラスを追加することもできる。

【テストがしやすくなる】

クラスを変更できれば、スタブを用意して簡単にテストができるようになる。スタブとは、ダミーの処理を記述したクラスのことで、例えば、メール送信の機能を実装するとする。メールを送信せずに、メール内容をログに出すようなスタブを用意する。こうすれば、メールが送信できなくても、メール送信前後の処理をテストすることができる。

[参考: 後悔しないための Spring Boot 入門書：Spring 解体新書（第 2 版）: Spring Boot が丸分かり Spring 解体新書](https://www.amazon.co.jp/%E5%BE%8C%E6%82%94%E3%81%97%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%E3%81%AESpring-Boot-%E5%85%A5%E9%96%80%E6%9B%B8%EF%BC%9ASpring-%E8%A7%A3%E4%BD%93%E6%96%B0%E6%9B%B8%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89-Spring%E8%A7%A3%E4%BD%93%E6%96%B0%E6%9B%B8-ebook/dp/B08XPBPH9C/ref=sr_1_2?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&keywords=%E5%BE%8C%E6%82%94spring&qid=1638163916&sr=8-2)

#### 依存性の注入を実施することで、モジュール同士の結合度の強さはどのように変化したでしょうか？

> 結合度とは、モジュールを変更しやすいように適切に分割できているかどうかを示す指標。密結合な（結合度が高い）システムでは修正が困難になるため、疎結合な（結合度が低い）システムがよいとされる。  
> [引用: 「実践ドメイン駆動設計」から学ぶDDDの実装入門](https://www.shoeisha.co.jp/book/detail/9784798161501)

依存性の注入を行うことで、モジュール同志の結合度の強さは低下した。  
例えば、親クラスAが呼び出している子クラスBを削除したとする。親クラスAには、「クラスBを生成して呼び出す」コードが記述されているため、クラスBが存在しないためエラーになる。つまり、クラスBを削除するときは、クラスAの修正が必要になる。  
依存性の注入を行うことで、依存性の記述をクラスの中から追い出し、まるでボタンを外すように、削除や変更を可能にした。

![zu01](https://user-images.githubusercontent.com/49358142/143835749-0e799090-345a-4bf9-b2f3-4d5738304bb6.jpg)  
[出典: プログラム間にボタンを掛ける「DI/AOP」](https://xtech.nikkei.com/it/article/COLUMN/20080228/294949/)

### 問題 2

#### 今回のような単体テストで外部サービスとの通信が発生すると、どのようなデメリットがあるでしょうか？

デメリットとして2つ考えられる

1. テストコードの結果が不規則  
通信している外部APIは、ランダムなデータを返すAPIであり、常にレスポンス結果が不規則だった。

2. テスト結果が反映されるまでの時間を短縮  
毎回、APIと通信を行うため、実行結果がCPUの実行速度と比較して遅くなる。
