# 課題 44

## 課題1

### 問題1

- [useEffect](https://ja.react.dev/reference/react/useEffect)
- [エフェクトを使って同期を行う](https://ja.react.dev/learn/synchronizing-with-effects)
- [エフェクトは必要ないかもしれない](https://ja.react.dev/learn/you-might-not-need-an-effect)
- [リアクティブなエフェクトのライフサイクル](https://ja.react.dev/learn/lifecycle-of-reactive-effects)
- [イベントとエフェクトを切り離す](https://ja.react.dev/learn/separating-events-from-effects)
- [エフェクトから依存値を取り除く](https://ja.react.dev/learn/removing-effect-dependencies)

### 問題2

- `useEffect`フックを利用することで、React コンポーネントのレンダリングサイクル後に定義された副作用を実行することができます。これにより、コンポーネントの描画後に必要な動作を実行することができます。
- 重要なのは、これらの副作用に関連した適切なクリーンアップ（後始末）ロジックを実装することです。これにより、副作用によって生じる可能性のあるメモリリークやリソースの不適切な使用を防ぐことができます。
- 特定のエフェクトは、その実行を停止し、元の状態に戻す、あるいはその他のクリーンアップ処理を行うためのロジックを含む必要があります。
  - 具体例として、外部APIへの「接続」エフェクトは、不要になった際に「切断」処理を要し、「イベントの登録」は、それを必要としなくなった時に「解除」を要し、「データの取得」は、その必要がなくなった場合に「キャンセル」または「無視」する処理が必要です。
- Reactでは、エフェクトが再実行される前に、毎回クリーンアップ関数が呼び出されます。さらに、コンポーネントがアンマウント（削除）される際にも、最後にこのクリーンアップ関数が実行されることで、リソースの適切な解放が保証されます。

### 問題3

- 何も指定しなかった場合：
  - エフェクトはすべてのレンダー後に実行されます。
- 空の配列（[]）を指定した場合：
  - コンポーネントが画面上に初めて「マウント」された時、つまり表示された時にのみ実行されます。

## 課題2

### 問題1

https://codesandbox.io/p/sandbox/p-challenge-44-2-1-mzskc2

### 問題2

- デフォルトでは、エフェクトはすべてのレンダリング後に実行されます。
- エフェクトの実行がstateの更新を引き起こし、再レンダリングが発生します。
- の再レンダリングにより、エフェクトが再度実行され、stateが更新され、これが繰り返されることになります。
- この結果、無限ループが発生します

備考

- React は、useRef フックを使用する際に、常に同一のオブジェクトを返すことを保証します。
- このオブジェクトは変更されないため、エフェクトの再実行を誘発することはありません。

### 問題3

https://codesandbox.io/p/sandbox/p-challenge-44-2-3-5mkdsk

## 課題3

### 問題1

https://codesandbox.io/p/sandbox/p-challenge-44-3-1-tx875x
